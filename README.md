 # **Karina College**

📌 **프로젝트 소개**

    트래픽이 몰릴 수강용 시스템만 분리해 서비스별 확장을 위해 
    수강신청용 대학교 사이트를 학생용과 수강신청용으로 나누어 MSA 방식으로 개발하고 
    수강 신청 기간에 과도한 트래픽을 서버가 감당하지 못해서 원활하게 진행하지 못하는 경우를 대비하기 위해 
    쿠버네티스, AWS 클라우드를 사용해 구축하였습니다.


📌 **사용스킬**

      java, aws, gitAction, argoCD, prometheus, MariaDB, SpringBoot, VSCode, kubernetese, Grafana, terraform, JWT


📌 **진행기간**

    2023/12/26 → 2024/02/06


📌 **팀원**

     김하린아, 한찬희, 문원선, 황지현
     
     
# **담당기능**

- **DEV**
    
    
    **회원** 
    
    - 관리자 기능 제외한 전체적인 회원 기능
    
    **수강신청**
    
    - 수강신청 사이트 오픈
    - 강의 조건별 검색
- **OPS**
    
    
    **쿠버네티스**
    
    - eks
    - 로드밸런서 생성
    - Ingress - url 통한 MSA 서비스 구분
    
    **테라폼** 
    
    - vpc
    - 서브넷
    - ecr
    - eks
    - bastion EC2
    - 보안그룹

## **1. Dev**


- **회원용과 수강신청용 서비스로 나누어 MSA로 프로젝트를 설계**

- **회원 서비스**

    로그인 (JWT 이용)
     
    학생 정보 조회
    
    학번조회 (SMS 본인인증)
    
    비밀번호 변경 (SMS 본인인증)
    
- **관리자 서비스**
    
    학생/ 강의/ 교수 각각 추가, 수정, 삭제
    
- **수강신청 서비스**
    
    수강신청 사이트 오픈  
    
    강의 조건별 검색 (강의명, 과목코드, 교수, 날짜, 시간, 학과 등)
    
    수강 카트 담기 및 신청
    
    시간표
  
    
### **1. 주요 개발 사항**
    
  가. 비밀번호 암호화
   - BcryptPasswordEncoder를 통해 비밀번호를 암호화해 DB에 저장하였습니다.
     
  나. 조건별 과목 검색   
   - ajax를 사용해 검색기능을 구현하였습니다. 그리고 시간 클릭할 때마다 시작시간 순 으로 오름차순 내림차순 정렬이 될 수 있도록 하였습니다.
     
  다. sms인증
   - 학번 조회를 할 때는 sms인증을 통해 본인인증을 할 수 있도록 하였습니다.
   - sms인증은 쿨sms 서비스를 이용해서 구현하였습니다.

    
### **2. OpenFeign, JWT**
  - 세션을 사용할 수 없어서 로그인 여부 확인을 위해 **OpenFeign, JWT**를 고려하였습니다
  - JWT값만 넘긴다면 각 프로젝트, DB의 연동성이 크게 없어서 RESTApi를 굳이 사용할 필요가 없다는 판단
      
       → 실제 적용은 JWT만 사용
      
  - 각 기능 설명
      1. OpenFeign
          - 선언적인 REST 클라이언트로서 서비스 간의 통신을 자동화합니다.
          - 인터페이스 기반의 API 정의로 간단하고 직관적인 코드 작성이 가능합니다.
      2. JWT(Jason Web Token)
          
          JWT는 로그인 시에 서버에서 로그인 정보를 담은 토큰을 시크릿 키를 이용해 생성 후 http 헤더에 담아 클라이언트로 보내 쿠키나, 로컬 스토리지 등에 저장 후 다시 서버로 보내 점검을 통해 토큰이 유효한 지 검증합니다.


## 2. Ops


 📌 **인프라 구성요소**

  **Route 53**   -도메인 연결 
      
   **CI/CD**     -CI : 깃액션, CD : ArgoCD 
      
   **ECR**        -빌드 된 프로젝트 이미지 저장  
      
   **EKS**        -쿠버네티스 관리 
      
   **Kubernetes**  -WorkerNode Autoscale, ingress 
      
   **Terraform**   -전체 프로젝트 한번에 관리 가능하도록 구축 
      
   **Prometeus**   -지표를 데이터로 수집, 저장 
      
   **Grafana**     -prometeus로 모니터링 된 결과를 시각화 
   



1. **CI/CD**
    
    변경 전 CI :  Git Server + jenkins CI로 구성
    
    변경 후 CI : GitAction
    
    ✏️**Git Server + jenkins**
    
    - **구성방법**
        
        1)  EC2 내부에 Git, jenkins 설치
        
        2)  Git의 소스코드를 Jenkins가 build 하기 위해 권한 등록
        
        3)  jenkins를 통해 build 구성
        
    
    **→ 초반 Git Server + jenkins CI 선택 이유**
    
    - 코드의 외부 노출을 방지하기 위해 gitServer로 구성
    
    ✏️**GitAction** 
    
    - **구성방법**
        
        1)  AWS ecr 생성 후 repoditory secrets에 등록

           - AWS_ACCESS_KEY
           - AWS_SECRET_ACCESS_KEY
      
        
        2)  Action Script yaml파일 작성
        
            ecr login → dockerfile을 통해 build → helm차트 업데이트
        
    
    **→ GitAction 으로 변경 이유**
    
     - Git과 Jenkins를 위해 인스턴스 추가 사용 → **비용 낭비**
       
     - 편의성 : 보다 간단하고 빠르게 CI 구성 가능
       
     - GitServer에서는 GitHub 처럼 편하게 소스 코드 보는 게 불가능
        
        

---

2. **Kubernetes**
    1)  기본설정
       
       a. AWS EKS를 활용한 kubernetes 구성

         - Terraform 모듈을 사용
         - irsa = true
         - AWS 사용자와 kubernetes 계정 연동
                   
       
       b. Worker Node 사이즈 설정
         - 최소 사이즈 1
         - 최대 사이즈 3
         - 원하는 사이즈 2
   

    2) 로드밸런서/ ingress
    
       **각각의 서비스를 찾아가도록 AWS alb, ingress 사용**
       
       MSA 프로젝트 → url을 통해 각 service를 구분
       
       - student svc
       - sugang svc
           
           
           | student svc | / |
           | --- | --- |
           |  | /student |
           |  | /admin |
           | sugang svc | /sugang |
           | monitoring svc | /monitoring |
       
       **ingress를 활용해 url별로 각 서비스를 찾아갈 수 있도록 설정**
    

---

3. **Terraform**
    
    AWS 콘솔로 생성했던 vpc, subnet, ECR, 보안그룹, EC2등을  Terraform코드를 사용해 구현
    
    - eks, ec2 사용 시 비용 문제로 구축할 기간 동안 계속 유지가 불가능
        
        → 콘솔에서 계속 지운 후 다시 셋팅 시의 시간낭비
        
    - 한번에 apply, destroy 함으로써 빠르게 구축해 세부사항 들을 보완
    - 세팅한 내용들을 코드로써 한번에 확인 및 수정의 편의성
    

---

### ✔️ **요약**

- **CI/CD** :  GitHub에 소스크드 repository에 push할 경우 이를 감지해 Git Action 이 동작하고
Docker Image 파일로 빌드를 진행합니다. AWS ECR로 image를 배포하게 됩니다.
    
    그 후 Pull Request로 HelmChart가 저장된 Repository에 또 다른 Git Action을 동작시켜 ArgoCd가 변경된 이미지를 보고 동기화하여 새로운 image를 배포할 수 있게 했고 이전에 build된 이미지와 image tag로 구분하여 버전 관리도 가능하게 구성 했습니다.
    
- 사용자는 **Domain**을 통해 접근한 후 **WAF**를 거친 후 **로드밸런서**를 통해 ECR의 이미지를 EKS에 있는 노출된 pod로 통해 접속하도록 구성하였습니다.
- 트래픽이 몰릴 경우 필요한 서비스만 **scale out** 하기 위해 **MSA**방식을 도입하였습니다.  **ingress**를 사용하여 **url 구분**을 통해 학생 용과 수강 신청 용 사이트를 분리하였습니다.
- **prometeus**와 **grafana**를 이용해 모니터링 할 수 있도록 하였습니다.

# 3. 보완점 및 느낀점

실질적인 인프라 구축과 MSA 형식으로는 처음 프로젝트를 해봐서 **경험을 해봐야 제대로 된 장단점을 알 수 있다**고 생각해 팀원들에게 고민 되는 방식이 있다면 서로 나누어서 여러 방식을 시도해보고 각자의 느낀점들을 서로 비교 후 판단하자고 제시를 해 저희 팀은 다소 시간이 걸리더라도 여러 방식을 시도해 많을 회의를 통해 방식을 결정하였습니다. 

로그인 방식에서 토큰 유지를 시키는 방법, CI/CD시에 많은 용량을 필요로 해서 예산을 늘리거나 다른 방식의 CI/CD를 선택 해야 하는 과정 등에서 어려움이 있었습니다. 

로그인 여부를 판별하는 과정에서 세션 사용이 불가능해서 REST API나 JWT를 고려하던 과정에서 각각의 방식으로 시도해본 후 공유할 데이터가 많지 않음을 고려했을 때 JWT방식을 선택하는 것이 가격 면에서 좀 더 유리 할 것이라는 판단을 내렸고 토큰을 판별하기 위해 잘 사용해보지 않았던 AJAX를 모든 기능에 사용해야 하는 경우가 생겨 많은 시간이 걸렸습니다. 

MSA로 프로젝트를 진행한 결과 좀 더 큰 용량의 EC2가 필요하게 되면서 jenkins + github를 사용했던 CI/CD방식을 중간에  GitAction을 사용한 CI로 바꾸게 되면서 많은 시간을 보내게 되었습니다. 그렇지만 그 덕분에 좀 더 많은 방식의 개발, CI/CD를 시도해 볼 수 있었고 각각의 장단점, 빌드 할 시의 속도차이 등을 바로 비교가 가능하게 되면서 오히려 좋았다고 생각합니다.

쿠버네티스 적용 시에 들여쓰기나 OIDC의 오타로 인해 정책, 역할이 올바르게 생성되지 않아서 로드밸런서가 생기지 않아서 시간을 허비하기도 하면서 사소하다고 생각했던 오타 문제가 제일 바로 잡기 힘들다는 것을 느꼈습니다. 그 뒤로는 오타를 좀 더 꼼꼼히 살펴보게 되었습니다. 

Ingress를 URL을 통해 분리를 할 때 URL 정리가 완벽히 되지 않아서 다시 개발 단계로 돌아가기도 하였습니다.

아쉬웠던 점은 s3에 css를 위한 이미지 파일 등을 따로 보관해 경량화를 하고 싶었지만 용량이 그렇게 크지 않았던 관계로 시간 관계상 포기했던 점과 개발과 인프라 팀의 진행 과정을 서로 공유하고 시도 해볼 수 있도록 각각 스터디 시간을 중간 중간 갖기로 했던 목표는  완료하지 못하였습니다. 하지만 각자 서로의 진행 과정을 대략 정리 해놓았기에 프로젝트 완료 후에 내가 하지 않은 파트까지 공부해 볼 수 있었습니다.
